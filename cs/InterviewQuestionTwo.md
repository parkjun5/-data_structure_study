## Q1 MSA
### Q1-1. MSA와 모놀리틱의 차이
    MSA(Microservices Architecture, 마이크로서비스 아키텍처)와 모놀리틱(Monolithic) 아키텍처는
    소프트웨어 개발에서 사용되는 두 가지 주요한 시스템 설계 패턴입니다.
    각각의 아키텍처는 애플리케이션을 구성하는 방식에서 큰 차이를 보이며, 각각의 장단점이 있습니다.

#### 모놀리틱 아키텍처
    정의: 모놀리틱 아키텍처에서는 애플리케이션의 모든 기능이 단일 애플리케이션 코드 베이스 내에 통합되어 있습니다.
         일반적으로 하나의 대규모 코드 베이스로 구성되며, 애플리케이션의 모든 부분이 서로 밀접하게 연결되어 있습니다.
    장점:
    - 개발, 배포 및 관리가 비교적 단순합니다.
    - 통합 및 엔드투엔드 테스팅이 용이합니다.
    - 초기 개발 속도가 빠를 수 있습니다.
    단점:
    - 애플리케이션의 규모가 커짐에 따라 관리 및 이해하기 어려워질 수 있습니다.
    - 기술 스택이 고정되어 유연성이 떨어질 수 있습니다.
    - 대규모 시스템에서 개발 및 배포 속도가 저하될 수 있습니다.
#### 마이크로서비스 아키텍처
    정의: MSA에서는 애플리케이션을 작은, 독립적으로 배포 가능한 서비스의 집합으로 구성합니다.
         각 마이크로서비스는 특정 비즈니스 기능을 수행하며, 서로는 가볍게 연결되어 있거나(API를 통해) 독립적으로 운영됩니다.
    장점:
    - 각 서비스가 독립적으로 개발, 배포 및 확장될 수 있어 시스템 전체의 유연성과 확장성이 향상됩니다.
    - 다양한 기술 스택과 프로그래밍 언어를 사용할 수 있어 기술적 유연성이 높습니다.
    - 큰 시스템에서도 개발 및 배포 속도를 유지할 수 있습니다.
    단점:
    - 복잡한 서비스 간 통신과 데이터 관리가 필요합니다.
    - 배포 및 운영 관리의 복잡성이 증가합니다.
    - 분산 시스템 설계의 복잡성으로 인해 디버깅과 테스팅이 어려워질 수 있습니다.
결국 선택은 프로젝트의 요구 사항, 팀의 경험, 기술 스택, 그리고 애플리케이션의 예상 성장 규모 등 다양한 요소를 고려하여 결정되어야 합니다.\
초기에는 모놀리틱 아키텍처로 시작하여 애플리케이션이 성장함에 따라 마이크로서비스로 전환하는 경우도 있습니다.

### Q1-2. 언제 MSA로 전환해야하는가?
    MSA(Microservices Architecture, 마이크로서비스 아키텍처)로 전환하는 것은 상당한 이점을 가져다줄 수 있지만,
    동시에 여러 도전과제도 수반합니다.
    따라서 MSA로의 전환은 신중하게 고려되어야 하며, 다음과 같은 상황에서 전환을 고려할 수 있습니다
1. 확장성의 필요성\
   애플리케이션이 성장함에 따라 특정 기능이나 서비스를 독립적으로 확장할 필요가 생겼을 때, MSA는 각 서비스를 개별적으로 확장할 수 있게 해줍니다.
2. 기술 스택의 유연성\
   다양한 기술, 언어, 데이터베이스를 프로젝트 내에서 사용해야 할 필요성이 있을 때, MSA는 각 마이크로서비스가 최적의 기술 스택을 선택할 수 있는 유연성을 제공합니다.
3. 대규모 팀에서의 협업\
   대규모 개발 팀이 여러 기능 영역에서 동시에 작업해야 할 때, MSA는 서비스별로 팀을 나누어 각자의 서비스에 집중할 수 있게 하여 협업을 용이하게 합니다.
4. 복잡성 관리\
   애플리케이션의 복잡성이 관리하기 어려운 수준에 도달했을 때, 마이크로서비스는 기능을 더 작고 관리하기 쉬운 부분으로 분할하여 복잡성을 줄일 수 있습니다.
5. 서비스의 장애 격리\
   시스템의 일부분에 문제가 발생했을 때 전체 시스템에 영향을 미치지 않도록 하고 싶을 때, 마이크로서비스는 서비스 간의 격리를 통해 장애의 영향을 제한할 수 있습니다.
6. 지속적인 통합 및 배포(CI/CD)\
   지속적인 통합 및 배포 프로세스를 통해 자주 그리고 신뢰성 있게 변경 사항을 배포하고 싶을 때, 마이크로서비스는 독립적인 배포가 가능하여 CI/CD를 효과적으로 구현할 수 있습니다.
   이러한 요인들을 고려하여, 현재 시스템의 문제점과 비즈니스 목표를 기반으로 MSA로의 전환을 결정해야 합니다. 또한, MSA 도입 시 발생할 수 있는 복잡성, 네트워크 오버헤드, 데이터 일관성 관리 등의 문제를 해결할 준비가 되어 있어야 합니다.
### Q1-3. MSA에서 서버상에 바라볼 수 있는 장점
1. 확장성
   독립적인 확장: 각 마이크로서비스는 독립적으로 배포되고 확장될 수 있어, 특정 서비스의 요구 사항에 따라 자원을 효율적으로 할당하고 조정할 수 있습니다.
   탄력적인 확장: 부하가 많은 서비스만을 대상으로 자동 확장 및 축소를 구현할 수 있어 자원 사용의 효율성을 높일 수 있습니다.
2. 내결함성(Fault Isolation)
   서비스 격리: 한 서비스의 장애가 전체 시스템으로 확산되는 것을 방지하고, 장애 발생 시 해당 서비스만을 격리 및 복구함으로써 시스템의 안정성을 높일 수 있습니다.
3. 배포 용이성
   독립적 배포: 각 마이크로서비스는 독립적으로 배포될 수 있어, 새로운 기능의 출시나 업데이트가 전체 시스템의 다운타임 없이 가능합니다.
   지속적인 배포: 마이크로서비스 구조는 지속적인 통합(CI) 및 지속적인 배포(CD)를 촉진하여 더 빠른 제품 반복과 혁신을 가능하게 합니다.
4. 기술적 유연성
   다양한 기술 스택: 각 마이크로서비스는 다른 서비스와 독립적이기 때문에, 서비스별로 가장 적합한 기술과 언어를 선택할 수 있습니다.
   기술 부채 감소: 새로운 기술을 실험하거나 기존 기술을 새로운 것으로 교체하기가 더 용이합니다.
5. 팀의 생산성
   소규모 팀: 마이크로서비스는 작고 자율적인 팀에서 관리하기에 적합하며, 이는 팀의 집중도를 높이고 책임 소재를 명확히 합니다.
   병렬 개발: 서비스가 서로 독립적으로 개발될 수 있어 여러 팀이 동시에 다른 서비스에서 작업할 수 있습니다.
6. 보안
   세분화된 보안: 각 마이크로서비스는 독립적인 보안 요구 사항과 정책을 가질 수 있어, 보안을 더 세분화하고 강화할 수 있습니다.
7. 서비스 재사용성
   재사용 가능한 컴포넌트: 마이크로서비스는 재사용 가능한 컴포넌트로 설계될 수 있어, 다른 애플리케이션 또는 서비스에서 같은 기능을 재사용할 수 있습니다.
<hr>

## Q2 메시지큐
### Q2-1. 카프카와 레디스 펍섭의 구조상의 차이
Apache Kafka와 Redis Pub/Sub은 둘 다 메시징 시스템이지만, 설계 철학과 사용 사례에서 상당한 차이가 있습니다.\
이 차이점을 이해하려면 각 시스템의 기본 구조와 기능을 살펴볼 필요가 있습니다.

#### Apache Kafka
Kafka는 분산 스트리밍 플랫폼으로, 높은 처리량, 내구성, 확장성을 제공합니다.\
Kafka는 대규모 데이터 파이프라인과 스트리밍 애플리케이션을 위해 설계되었습니다.\
Kafka의 핵심 구성 요소와 특징은 다음과 같습니다:

> 토픽(Topics):\
> Kafka는 메시지를 토픽이라는 카테고리로 분류합니다. 프로듀서(생산자)는 특정 토픽에 메시지를 발행하고, 컨슈머(소비자)는 토픽을 구독하여 메시지를 수신합니다.
> 
> 파티션(Partitions):\
> 각 토픽은 여러 파티션으로 나뉠 수 있으며, 이는 메시지의 병렬 처리와 확장성을 가능하게 합니다.
> 
> 브로커(Brokers):\
> Kafka 클러스터는 여러 브로커로 구성되며, 각 브로커는 메시지를 저장하고 전송하는 노드 역할을 합니다.
> 
> 오프셋(Offsets):\
> Kafka는 각 메시지에 오프셋(고유 식별자)을 할당하며, 컨슈머는 이 오프셋을 사용하여 이미 처리한 메시지와 처리해야 할 메시지를 관리합니다.
> 
> 내구성(Durability):\
> 메시지는 디스크에 저장되며, 설정에 따라 일정 시간 또는 크기에 도달할 때까지 보존됩니다.

#### Redis Pub/Sub
Redis는 고성능 인메모리 키-값 저장소로, 다양한 데이터 구조를 지원합니다.\
Redis Pub/Sub은 실시간 메시징, 알림, 채팅 시스템 등을 위한 간단하고 가벼운 메시징 솔루션을 제공합니다.\
Redis Pub/Sub의 주요 특징은 다음과 같습니다:
> 퍼블리셔(Publishers)와 서브스크라이버(Subscribers):\
> 퍼블리셔는 특정 채널에 메시지를 발행하고, 서브스크라이버는 하나 이상의 채널을 구독하여 메시지를 수신합니다.
> 
> 채널(Channels):\
> 메시지는 채널을 통해 전송되며, 서브스크라이버는 관심 있는 채널을 구독합니다.
> 
> 메모리 기반:\
> Redis는 모든 데이터를 메모리에 저장하기 때문에 빠른 성능을 제공하지만, 메시지가 영구적으로 저장되지는 않습니다.
> 
> 간단함과 가벼움:\
> Redis Pub/Sub은 Kafka에 비해 더 가벼우며 설정과 관리가 간단합니다. 그러나 Kafka만큼의 내구성이나 데이터 처리량을 제공하지는 않습니다.

#### Kafka와 Redis Pub/Sub의 주요 차이점
> 데이터 저장:\
> Kafka는 메시지를 디스크에 저장하여 내구성을 보장하는 반면, Redis Pub/Sub은 메모리에만 메시지를 저장하여 빠르게 소비되도록 합니다.
> 
> 처리량과 확장성:\
> Kafka는 높은 처리량과 확장성을 위해 설계되었으며, 대규모 데이터 스트림 처리에 적합합니다. Redis Pub/Sub은 가볍고 빠르지만 대규모 분산 시스템에서 Kafka만큼의 성능을 제공하지는 않습니다.
> 
> 메시지 보존:\
> Kafka는 설정에 따라 메시지를 일정 시간 동안 또는 영구적으로 보존할 수 있습니다. 반면 Redis Pub/Sub에서는 메시지가 구독자에게 전달되면 즉시 제거됩니다.
> 
> 사용 사례:\
> Kafka는 로깅, 이벤트 소싱, 실시간 분석 등과 같은 복잡하고 데이터 집약적인 애플리케이션에 적합합니다. Redis Pub/Sub은 실시간 알림, 채팅, 실시간 대시보드 등과 같이 가볍고 실시간 통신이 필요한 애플리케이션에 더 적합합니다.

### 큐잉에서의 차이
Apache Kafka와 Redis Pub/Sub 모두 내부적으로 메시지를 큐잉(queueing)하는 메커니즘을 사용하지만,\
이 큐의 구현과 작동 방식에서 중요한 차이가 있습니다.

#### Apache Kafka의 큐 메커니즘
> 분산 로그 시스템:\
  Kafka는 분산 로그 시스템으로 설계되어 있습니다.\
> 각 토픽은 하나 이상의 파티션으로 나뉘며, 각 파티션은 순서가 지정된 메시지들의 로그를 유지합니다.\
> 이 로그는 디스크에 저장되며, 메시지는 추가될 때마다 고유한 오프셋을 받습니다.
> 
> 오프셋 관리:\
  컨슈머는 각 파티션에서 마지막으로 읽은 메시지의 오프셋을 추적합니다.\
  이를 통해 컨슈머가 중단되었다가 다시 시작될 때 마지막으로 읽은 위치부터 메시지를 다시 읽을 수 있습니다.
> 
> 내구성과 보존 정책:\
> Kafka의 메시지는 설정된 보존 기간 동안 또는 로그 크기에 따라 디스크에 저장됩니다.\
  이는 메시지가 소비되더라도 바로 삭제되지 않고, 설정된 기간 동안 또는 영구적으로 저장될 수 있음을 의미합니다.

#### Redis Pub/Sub의 큐 메커니즘
> 인메모리 메시징 시스템:\
> Redis Pub/Sub은 인메모리 데이터 구조를 사용하는 퍼블리시/서브스크라이브 메시징 시스템입니다.\
> 메시지는 메모리에만 존재하며, 구독자에게 전달된 후에는 메시지가 사라집니다.
>
> 비영속 메시징:\
> Redis Pub/Sub에서 메시지는 영속적으로 저장되지 않습니다.\
> 즉, 구독자가 연결되어 있지 않은 상태에서 발행된 메시지는 영원히 손실됩니다.\
> 이는 메시지를 나중에 다시 검색할 수 없음을 의미합니다.
> 
> 채널 기반 메시징:\
> 메시지는 채널을 통해 전송되며, 서브스크라이버는 하나 이상의 채널을 구독하여 메시지를 수신합니다.\
> 메시지는 채널에 연결된 모든 구독자에게 실시간으로 전달됩니다.

### 큐 메커니즘의 주요 차이점
> 영속성:\
> Kafka는 메시지를 디스크에 저장하여 영속성을 보장하는 반면, Redis Pub/Sub은 메모리에만 메시지를 임시로 저장합니다.
> 
> 메시지 순서와 보존:\
> Kafka는 파티션 내에서 메시지의 순서를 보장하며, 설정된 기간 동안 메시지를 보존합니다.\
> Redis Pub/Sub에서는 메시지가 구독자에게 전달되면 즉시 사라집니다.
> 
> 확장성과 처리량:\
> Kafka는 분산 시스템으로 설계되어 높은 처리량과 확장성을 제공합니다.\
> Redis Pub/Sub도 높은 성능을 제공하지만, Kafka만큼의 대규모 분산 처리에는 적합하지 않을 수 있습니다.

따라서 둘 다 큐 메커니즘을 내포하고 있지만,\
Kafka는 영속적인 메시지 저장과 처리를 위한 분산 로그 시스템으로,\
Redis Pub/Sub은 실시간, 경량의 메시징 시나리오를 위한 인메모리 메시징 시스템으로 각각 설계되었습니다.

### Q2-2. 레디스에서 publish 되는 방식
### Q2-3. 레디스에서 펍을 했는데, 만약 구독자가 없으면 어떻게 되는가

Redis Pub/Sub에서 메시지를 발행(pub)했지만 구독자(subscriber)가 없는 경우, 해당 메시지는 소실됩니다.\
Redis Pub/Sub 시스템은 메시지를 메모리에만 임시로 저장하며, 메시지가 구독자에게 전달된 후에는 메모리에서 제거됩니다.\
만약 구독자가 해당 메시지를 받을 준비가 되어 있지 않거나, 해당 채널을 구독하는 구독자가 전혀 없는 경우 메시지는 어디에도 저장되지 않고,\
누구에게도 전달되지 않으며, 단순히 소실됩니다.

Redis Pub/Sub 시스템은 영속적인 메시지 저장을 지원하지 않기 때문에, 메시지의 내구성이 중요한 경우 다른 방법을 고려해야 합니다.\
예를 들어, 메시지가 소실되지 않고 항상 처리될 수 있도록 보장해야 하는 시나리오에서는 Redis의 다른 기능인 리스트(lists)나\
스트림(streams)을 사용하거나, Kafka와 같은 다른 메시징 시스템을 고려할 수 있습니다.\
Redis 스트림은 특히 메시지의 영속성을 보장하면서도 Pub/Sub 패턴을 사용할 수 있게 해주는 좋은 대안이 될 수 있습니다.

### Q2-4. 레디스에서 배동되지 못한 큐를 처리하는 방법

<hr>

## 트랜잭션
### 트랜잭션 ACID 설명
- 원자성(Atomicity)\
트랜잭션에 속한 각각의 문(데이터를 읽기, 쓰기, 업데이트 또는 삭제하기 위함)을 하나의 단위로 취급합니다.\
문 전체를 실행하거나 그 문의 어떤 부분도 실행하지 않거나 둘 중 하나입니다.\
이 속성이 있으면 예컨대 스트리밍 데이터 소스가 스트리밍 중에 갑자기 오류를 일으키더라도 데이터 손실과 손상이 방지됩니다.
- 일관성(Consistency)\
트랜잭션이 테이블에 변경 사항을 적용할 때 미리 정의된, 예측할 수 있는 방식만 취합니다.\
트랜잭션 일관성이 확보되면 데이터 손상이나 오류 때문에 테이블 무결성에 의도치 않은 결과가 생기지 않습니다.
- 격리(Isolation)\
여러 사용자가 같은 테이블에서 모두 동시에 읽고 쓰기 작업을 할 때, 각각의 트랜잭션을 격리하면 동시 트랜잭션이 서로 방해하거나 영향을 미치지 않습니다.\
각각의 요청이 실제로는 모두 동시에 발생하더라도, 마치 하나씩 발생하는 것처럼 발생할 수 있습니다.
- 영속성(Durability)\
트랜잭션 실행으로 인해 데이터에 적용된 변경 사항이 저장되도록 보장합니다.\
시스템 오류가 발생해도 마찬가지입니다.
### 트랜잭션 고립성 설명 COMMITED READ VS REPEATABLE READ
    데이터베이스 시스템에서 트랜잭션 고립성(Isolation) 수준은 동시에 실행되는 여러 트랜잭션이\
    서로 영향을 주지 않도록 하는 데 필요한 규칙과 제약 조건을 정의합니다.\
    트랜잭션 고립성 수준은 일관성 있는 데이터를 유지하는 동시에 동시성을 최대화하는 데 중요한 역할을 합니다.\
    두 가지 주요 고립성 수준인 "Committed Read"와 "Repeatable Read"를 살펴보겠습니다.

1. Committed Read (커밋된 읽기)\
   커밋된 읽기는 가장 낮은 고립성 수준 중 하나로, 일반적으로 "Read Committed"라고도 불립니다.\
이 수준에서 트랜잭션은 다른 트랜잭션에 의해 커밋된 변경사항만 볼 수 있습니다.\
즉, 트랜잭션은 커밋되지 않은(미확정의) 변경사항을 볼 수 없습니다.
   - 장점: 높은 동시성과 낮은 잠금 오버헤드로 인해 시스템 성능이 좋습니다.
   - 단점: "Non-repeatable reads" 또는 "Fuzzy reads" 현상이 발생할 수 있습니다. 이는 한 트랜잭션 내에서 같은 데이터를 두 번 읽을 때, 첫 번째와 두 번째 읽기 사이에 다른 트랜잭션이 커밋되어 데이터가 변경될 수 있음을 의미합니다.
2. Repeatable Read (반복 가능한 읽기)\
   반복 가능한 읽기는 보다 높은 고립성 수준을 제공합니다.\
이 수준에서는 한 트랜잭션 내에서 같은 데이터를 여러 번 읽더라도 첫 번째 읽기 시점의 데이터를 계속해서 볼 수 있습니다.\
즉, 한 트랜잭션이 실행되는 동안 다른 트랜잭션에 의해 해당 데이터가 변경되어도 영향을 받지 않습니다.
   - 장점: "Non-repeatable reads" 문제를 방지합니다. 한 트랜잭션 내에서 데이터의 일관성을 유지할 수 있습니다.
   - 단점: 잠금(또는 다른 동시성 제어 메커니즘)의 확장된 사용으로 인해 동시성이 저하될 수 있으며, "Phantom reads" 현상이 여전히 발생할 수 있습니다.\
   "Phantom reads"는 한 트랜잭션 내에서 동일한 쿼리를 실행했을 때 결과 집합이 달라질 수 있는 현상입니다.\
   이는 다른 트랜잭션이 새로운 데이터를 삽입하거나 삭제하여 발생할 수 있습니다.

> 각 고립성 수준은 성능과 일관성 사이의 트레이드오프를 제공합니다.\
> "Committed Read"는 성능을 최적화하지만 데이터 일관성에 문제가 발생할 수 있으며,\
> "Repeatable Read"는 데이터의 일관성을 더 잘 보장하지만 성능에 영향을 줄 수 있습니다.\
> 실제 사용 시에는 애플리케이션의 요구 사항과 데이터베이스의 작업 부하를 고려하여 적절한 고립성 수준을 선택해야 합니다.


<hr>

## 일
### 일을 정량적으로 판단해서 나누는 방법