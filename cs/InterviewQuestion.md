__Q: 자바는 인터프리터 언어인가? 컴파일 언어인가?__

> 자바는 컴파일 언어입니다. \
> 자바 코드는 먼저 Java 컴파일러에 의해 바이트 코드로 컴파일되며,
> 이 바이트 코드는 JVM(Java Virtual Machine)에서 실행됩니다.
>
> 하지만 JVM에서 바이트 코드를 실행하는 과정은 인터프리터와 __JIT(Just-In-Time) 컴파일러__ 를 모두 사용합니다.\
> 먼저 인터프리터는 바이트 코드를 한 줄씩 읽어서 실행합니다.\
> 그런 다음, JIT 컴파일러는 빈번하게 실행되는 코드 부분을 머신 코드로 변환하여 프로그램의 실행 속도를 높입니다.
> 
> 그래서 일부는 자바를 하이브리드 언어라고도 말합니다. 하지만 전통적으로는 컴파일 언어로 분류됩니다.

__Q: 자바가 전통적으로는 C와 같은 언어보다는 느리다는 인식이 있었다. 하지만 최근에는 속도 차이가 거의 없다라고 한다. 그 이유는?__

> 자바가 C나 C++보다 느리다는 인식은 초기 JVM이 성능 측면에서 최적화되지 않았던 시점에서 온 것입니다.\
> 초기 JVM은 바이트코드를 해석하고 실행하는 방식인 인터프리터를 사용했기 때문에,\
> C/C++ 같은 컴파일 언어에 비해 실행 속도가 느렸습니다.
>
> 그러나 시간이 흐르면서 JVM은 많이 발전했습니다.\
> 특히, JIT(Just-In-Time) 컴파일러의 도입이 JVM의 성능을 크게 향상시켰습니다.\
> JIT 컴파일러는 자주 사용되는 코드를 실시간으로 머신 코드로 컴파일하고 최적화하여, 해당 코드의 실행 속도를 향상시킵니다.\
> 이를 통해 자바의 실행 속도가 크게 개선되었습니다.
>
> 또한, JVM의 가비지 컬렉션(GC), 쓰레드 관리 등의 기능도 계속해서 발전하고 있습니다.\
> 이러한 기능들은 프로그램의 성능을 향상시키고, 프로그래머가 성능 최적화에 대해 직접 걱정할 필요를 줄여줍니다.
>
> 따라서 현대의 JVM은 고성능이며, 자바 프로그램은 C나 C++ 프로그램과 비교하여 실행 속도 면에서 크게 뒤떨어지지 않습니다.\
> 하지만 특정 유형의 작업, 특히 시스템 수준의 프로그래밍이나 리소스 제약이 심한 환경에서는 C나 C++가 더 우수할 수 있습니다.

__Q: 아파치는 프론트 프록시를 사용할까, 리벅스 프록시를 사용할까__

> Apache HTTP 서버는 일반적으로 리버스 프록시(reverse proxy)로 사용됩니다.\
> 리버스 프록시는 클라이언트의 요청을 적절한 백엔드 서버로 전달하고, 그 응답을 클라이언트로 다시 전달하는 역할을 합니다.\
> 이를 통해 로드 밸런싱, SSL 종료, HTTP 트래픽의 압축 및 캐싱 등의 기능을 수행할 수 있습니다.
> 
> 반면에, 프론트 프록시(forward proxy)는 클라이언트를 대신해 인터넷에 요청을 보내는 역할을 합니다.\
> 일반적으로, 프론트 프록시는 클라이언트의 IP 주소를 숨기거나, 접근 제한이 있는 웹사이트에 접근할 때 사용됩니다.
> 
> 따라서, Apache HTTP 서버는 프론트 프록시로도 사용될 수 있지만, 일반적으로 리버스 프록시로 많이 사용됩니다.\
> 이는 Apache HTTP 서버의 기능과 구성 옵션, 그리고 웹 애플리케이션의 배포 및 관리에 있어 리버스 프록시가 흔히 필요하기 때문입니다.

__Q: 함수형 프로그래밍을 사용하는 이유와 장단점__

> 함수형 프로그래밍은 순수 함수를 사용하고, 상태 변경이나 변경 가능한 데이터를 피하며, 고차 함수를 사용하는 것을 중심으로 합니다.
> 
> 함수형 프로그래밍을 사용하는 주요 이유들은 다음과 같습니다:
> 
> 1. __수학적 함수에 기반한 설계__ \
> 함수형 프로그래밍에서 사용하는 순수 함수는 입력이 주어지면 항상 동일한 출력을 반환하고, 부작용이 없습니다.
> 이는 프로그램을 더 예측 가능하고 테스트하기 쉽게 만들어줍니다.
>
> 2. __불변성과 상태 변경의 최소화__ \
> 함수형 프로그래밍은 데이터의 불변성을 중요시합니다. 이는 프로그램의 상태를 변경하는 부분을 최소화하므로, 프로그램의 복잡성을 줄이고, 버그 발생 가능성을 줄여줍니다.
> 
> 3. __공유 상태, 스레드 안전성, 동시성 문제 감소__ \
> 함수형 프로그래밍의 이러한 특징들은 공유 상태나 변경 가능한 데이터에 대한 동시 액세스로 인한 문제를 줄여주므로, 병렬 처리와 동시성을 더 쉽게 만들어줍니다.
> 
> 하지만 함수형 프로그래밍 역시 단점을 가지고 있습니다:
> 
> 1. __학습 곡선__ \
> 함수형 프로그래밍은 고차 함수, 재귀, 모나드 등과 같은 새로운 개념을 많이 도입하므로, 학습 곡선이 가파를 수 있습니다.
> 2. __성능 이슈__ \
> 불변성과 재귀를 활용한 설계로 인해, 때로는 추가적인 메모리를 사용하거나, 성능에 미치는 영향이 있을 수 있습니다.
> 3. __디버깅 어려움__ \
> 표현식이 복잡하거나, 스택 트레이스가 재귀 함수로 인해 복잡해지면 디버깅이 어려울 수 있습니다.
> 4. __적용 분야 제한__ \
> 몇몇 상황에서, 특히 데이터를 많이 변경해야 하는 경우, 객체 지향 프로그래밍이나 절차적 프로그래밍이 더 적합할 수 있습니다.
> 
> 따라서, 함수형 프로그래밍은 프로젝트의 특정 요구 사항, 팀원들의 스킬, 그리고 프로젝트의 도메인에 따라 적합한 패러다임을 선택하는 것이 중요합니다.

__Q: 대표적인 로드밸런서 프로그램__

> 로드 밸런서는 네트워크 트래픽을 여러 서버로 분산시키는 역할을 합니다.\
> 로드 밸런싱은 시스템의 가용성과 신뢰성을 높이고, 요청을 처리하는 능력(capacity)를 늘리는 데 도움이 됩니다.
> 
> 다음은 몇 가지 대표적인 로드 밸런서입니다:
> 
> 1. __HAProxy__\
> HAProxy는 고성능, 고가용성의 로드 밸런서이며, TCP 및 HTTP 기반 애플리케이션에 사용됩니다. 오픈소스로 제공되며, 다양한 기능을 지원합니다.
> 
> 2. __Nginx__\
> Nginx는 웹 서버로 많이 사용되지만, 역시 강력한 로드 밸런서로서의 기능을 제공합니다. HTTP, HTTPS, SMTP, POP3 및 IMAP 프로토콜을 지원하며, 라운드 로빈, 최소 연결, IP 해시 등의 로드 밸런싱 알고리즘을 제공합니다.
> 
> 3. __Amazon ELB (Elastic Load Balancing)__\
> Amazon ELB는 AWS에서 제공하는 로드 밸런싱 서비스입니다. ELB는 자동으로 트래픽을 여러 Amazon EC2 인스턴스로 분산시키며, 가용성과 내결함성을 높여줍니다.
> 
> 위의 솔루션들은 각각의 특징과 장단점이 있으므로, 개별 서비스의 요구 사항에 따라 적절한 로드 밸런서를 선택하는 것이 중요합니다

__Q: 데이터를 암호화하는 알고리즘의 종류와 각 장단점__

> 데이터를 암호화하는 알고리즘은 크게 대칭 키 암호화 알고리즘과 비대칭 키 암호화 알고리즘으로 나눌 수 있습니다.\
> 각 알고리즘은 그 자체의 장단점이 있습니다.
> 
> 대칭 키 암호화 알고리즘:
> 
> 예시: AES (Advanced Encryption Standard), DES (Data Encryption Standard), Triple DES, Blowfish, RC4 등
> - __장점__ : 비교적 계산 속도가 빠르며, 데이터를 효율적으로 암호화합니다.
> - __단점__ : 암호화와 복호화에 같은 키를 사용하기 때문에 키 관리 및 배포가 어렵습니다. 만약 키가 유출되면, 암호화된 모든 데이터가 위험에 노출됩니다.
> 비대칭 키 암호화 알고리즘:
> 
> 예시: RSA, DSA (Digital Signature Algorithm), ECC (Elliptic Curve Cryptography), ElGamal, Diffie-Hellman 등
> - __장점__ : 공개 키와 개인 키라는 두 개의 키를 사용하므로, 키 배포 문제를 해결합니다. 또한, 데이터 통신의 무결성, 인증, 부인 방지 등을 제공합니다.
> - __단점__ : 대칭 키 암호화 방식에 비해 연산이 복잡하므로 처리 속도가 느립니다. 또한, 키의 길이가 길어야 안전성을 보장할 수 있어, 키 관리가 어려울 수 있습니다.\
> 
> 이 외에도, 암호화를 통해 데이터의 무결성을 검증하는 해시 함수 (SHA-256, SHA-3, MD5 등) 등이 있습니다.
> 
> 각 암호화 방식은 사용되는 환경, 필요한 보안 수준, 성능 요구 사항 등에 따라 적절하게 선택되어야 합니다.\
> 때로는 대칭 키와 비대칭 키 암호화를 결합한 하이브리드 암호화 방식이 사용되기도 합니다.

__Q: 자바에서 함수형 프로그래밍을 사용하는 페러다임을 설명해주세요__

> 자바는 기본적으로 객체지향 프로그래밍 언어입니다.\
> 그러나, 자바 8 버전부터 람다 표현식과 함수형 인터페이스의 도입으로 함수형 프로그래밍 패러다임을 지원하기 시작했습니다.
> 
> 함수형 프로그래밍의 핵심 원칙은 불변성(immutability)과 순수 함수(pure functions)의 사용입니다.\
> 불변성은 데이터가 한번 생성된 후에 변경되지 않는 것을 의미하며, 순수 함수는 주어진 입력에 대해 항상 같은 출력을 반환하며, 외부 상태를 변경하지 않는 함수를 의미합니다.
> 
> 자바에서 함수형 프로그래밍을 사용하는 패러다임을 살펴보면,
> 
> __람다 표현식:__\
> 람다 표현식을 이용하면, 함수를 변수에 할당하거나, 메소드의 인자로 전달하거나, 반환 값으로 사용하는 등 함수를 일급 시민(first-class citizen)으로 다룰 수 있습니다.
> 
> __Stream API:__\
> 자바 8에서 도입된 Stream API를 사용하면, 컬렉션에 대한 복잡한 데이터 처리를 선언적으로(즉, 어떤 방식으로 처리할지가 아니라 어떤 결과를 얻고자 하는지를 기술하는 방식) 할 수 있습니다.\
> 이는 가독성을 높이며, 멀티스레드 환경에서의 병렬 처리를 쉽게 할 수 있습니다.
> 
> __함수형 인터페이스:__\
> 함수형 인터페이스는 하나의 추상 메소드만 가진 인터페이스를 의미합니다.\
> 이를 통해 함수를 인자로 전달하거나 결과로 반환하는 고차 함수(higher-order function)의 개념을 구현할 수 있습니다.\
> Runnable, Callable, Comparator, Predicate, Function 등이 대표적인 예시입니다.
> 
> 위와 같은 방식으로 자바에서도 함수형 프로그래밍의 장점을 활용할 수 있습니다.\
> 하지만, 여전히 자바는 순수한 함수형 프로그래밍 언어는 아니므로, 객체지향 프로그래밍과 함수형 프로그래밍을 적절히 혼합하여 사용하는 것이 일반적입니다.

__Q: http 1.1 과 http 2.0 의 차이__

> HTTP 1.1과 HTTP 2.0 사이에는 여러 가지 중요한 차이점이 있습니다.\
> 이러한 차이점은 주로 성능 향상, 효율성 증가, 그리고 낮은 지연 시간에 초점을 맞추고 있습니다.
>
> __다중 연결 vs 단일 연결:__
> HTTP 1.1에서는 한 번에 하나의 요청을 처리하기 위해 여러 TCP 연결이 필요했습니다.\
> 이는 병렬 처리를 가능하게 하지만, 각 연결에 대한 오버헤드가 크고, 여러 연결이 경쟁 상태에 빠질 수 있습니다.\
> 반면 HTTP 2.0에서는 단일 TCP 연결을 통해 여러 개의 요청과 응답을 동시에 처리할 수 있는 다중화를 지원합니다.
>
> 스트림과 프레임:
> HTTP 2.0은 스트림과 프레임 개념을 도입했습니다.\
> 하나의 연결에서 여러 개의 스트림이 동시에 열릴 수 있으며, 각 스트림은 독립적인 요청과 응답을 처리합니다.\
> 각 스트림은 여러 개의 메시지로 구성되며, 이 메시지는 프레임으로 세분화됩니다. 이렇게 함으로써, HTTP 2.0은 여러 요청과 응답을 동시에, 순서에 상관없이 전송할 수 있습니다.
>
> 헤더 압축:
> HTTP 1.1에서는 헤더 데이터를 압축하지 않았습니다.\
> 반면에 HTTP 2.0에서는 HPACK 압축을 이용해 헤더 데이터를 압축합니다. 이를 통해 전체 메시지 크기를 줄이고, 전송 시간을 단축시킵니다.
>
> 서버 푸시:
> HTTP 2.0은 서버 푸시 기능을 제공합니다.\
> 이는 서버가 클라이언트의 요청에 대한 응답과 함께 추가 리소스를 전송할 수 있음을 의미합니다.\
> 예를 들어, 클라이언트가 웹 페이지를 요청하면, 서버는 HTML 파일 뿐 아니라 CSS와 JavaScript 파일도 함께 보낼 수 있습니다.\
> 이렇게 하면 클라이언트가 추가 요청을 보내지 않아도 되므로, 지연 시간이 줄어듭니다.
>
> 바이너리 프로토콜:
> HTTP 1.1은 텍스트 기반 프로토콜입니다.\
> 반면에 HTTP 2.0은 바이너리 프로토콜입니다.\
> 이는 바이너리 프로토콜이 텍스트 기반 프로토콜보다 효율적이며, 오류를 쉽게 발견하고 수정할 수 있음을 의미합니다.\
> 또한 바이너리 프로토콜은 네트워크를 통해 전송하기 위해 특별히 디자인되었습니다.

__Q: 암호화 복호화와 인코딩 디코딩의 차이__

> 암호화/복호화와 인코딩/디코딩은 정보를 변환하는 두 가지 주요 프로세스입니다.\
> 이 두 가지는 서로 다른 목적을 가지고 있으며, 다음과 같이 구분될 수 있습니다.
>
> __암호화/복호화:__\
> 이것은 정보를 보호하기 위해 사용되는 프로세스입니다.\
> 암호화는 정보를 알아보기 어렵게 변환하는 프로세스로, 특정 암호화 키가 있어야만 원래의 정보로 변환(복호화)할 수 있습니다.\
> 이는 데이터의 기밀성을 유지하고, 데이터가 전송 중에 도난당하거나 변조되는 것을 방지하는 데 사용됩니다.
>
> __인코딩/디코딩:__\
> 인코딩은 데이터를 특정 포맷으로 변환하는 프로세스입니다.\
> 이는 데이터를 안전하게 저장하거나 전송하기 위해 사용됩니다.\
> 예를 들어, 이메일을 전송할 때 메시지는 ASCII나 UTF-8과 같은 문자 인코딩 체계를 사용하여 문자열로 변환(인코딩)됩니다.\
> 메시지를 읽을 때, 문자열은 다시 원래의 데이터로 변환(디코딩)됩니다.
>
> 따라서, 암호화/복호화는 주로 보안 목적으로 사용되며, 인코딩/디코딩은 데이터를 안전하게 저장하거나 전송하기 위한 목적으로 사용됩니다.\
> 이 둘은 서로 다른 목적을 가지고 있지만, 때로는 함께 사용되기도 합니다.\
> 예를 들어, 데이터를 안전하게 전송하기 위해 먼저 데이터를 인코딩한 후 암호화할 수 있습니다.