# Q: MSA와 모놀리틱의 차이

## 모놀리틱 아키텍처
모놀리틱 아키텍처는 전통적인 소프트웨어 개발 방식으로, 애플리케이션의 모든 기능이 단일 프로그램 내에서 통합적으로 개발되고 배포되는 구조입니다.

## 특징:
### 1. 통합 코드 베이스:
모든 기능이 하나의 코드베이스 내에서 관리됩니다.
### 2. 단일 언어 및 기술 스택:
전체 애플리케이션이 일반적으로 한 가지 프로그래밍 언어 및 기술 스택을 사용하여 개발됩니다.
### 3. 단순한 배포:
전체 애플리케이션을 하나의 실행 가능 파일이나 워 파일로 패키징하여 배포합니다.

## 장점:
- 초기 개발의 단순성 및 속도
- 배포의 용이성
- 디버깅과 테스트의 편의성

## 단점:
- 확장성의 제한 >> 애플리케이션의 한 부분에 대한 변경이 전체 시스템에 영향을 줄 수 있습니다.
- 기술 스택에 대한 유연성 부족
- 대규모 팀에서의 협업 어려움

## 마이크로서비스 아키텍처 (MSA)
마이크로서비스 아키텍처는 애플리케이션을 작은, 독립적으로 배포 가능한 서비스들로 분할하는 접근 방식입니다.

## 특징:
### 1. 서비스 기반 분할:
애플리케이션은 여러 개의 작은 서비스로 나뉘며, 각 서비스는 특정 기능을 담당합니다.
### 2. 독립적인 개발 및 배포:
각 서비스는 독립적으로 개발, 배포, 확장될 수 있습니다.
### 3. 다양한 기술 스택
서비스별로 가장 적합한 기술과 프로그래밍 언어를 선택할 수 있습니다.

## 장점:
### 확장성:
서비스가 독립적이므로 특정 서비스만을 타깃으로 확장 가능
### 유연성:
다양한 기술을 사용하여 최적의 서비스를 설계할 수 있음
### 장애 격리:
한 서비스의 실패가 전체 시스템을 무너뜨리지 않음

## 단점:
### 복잡한 배포 및 운영:
여러 서비스를 관리해야 하므로 복잡도가 증가
### 서비스 간 통신 비용:
네트워크를 통한 서비스 간 통신이 필요함
### 데이터 일관성 유지 어려움:
분산된 데이터 관리의 복잡성 증가
### 요약
### 개발 및 배포의 복잡성
모놀리틱은 간단한 초기 개발과 배포를 제공하지만, MSA는 각 서비스의 독립적 관리가 가능하게 해 확장성과 유연성을 제공합니다.
### 확장성 및 장애 대응
MSA는 서비스별로 확장이 가능하고 장애 격리가 우수하지만, 모놀리틱은 전체 애플리케이션 수준에서만 확장 및 장애 대응이 이루어집니다.
### 기술 다양성
모놀리틱은 보통 단일 기술 스택에 제한되지만, MSA는 서비스별로 다양한 기술을 선택할 수 있는 유연성을 제공합니다.

> 이러한 차이점들을 고려하여, 각 프로젝트의 요구사항과 팀의 역량에 맞는 아키텍처 선택이 중요합니다.

# Q: 언제 MSA으로 가야하는가

## MSA로 전환을 고려해야 할 시점

### 규모의 확장성이 필요할 때:
서비스가 성장하면서 트래픽이 급증하거나 사용자 기반의 확장이 필요한 경우, MSA는 특정 서비스만을 타깃으로 리소스를 증가시키거나 축소할 수 있어 더 효율적인 확장이 가능합니다.
### 개발 팀의 확대:
프로젝트나 조직의 크기가 커지면서 개발 팀이 확대되는 경우, 모놀리틱 구조에서는 코드 베이스가 커져 개발과 유지보수가 어려워질 수 있습니다. MSA는 팀이 독립적으로 각자의 서비스에 집중할 수 있게 해주어 협업과 개발 속도를 향상시킬 수 있습니다.
### 기술 스택의 다양화 필요성:
다양한 기술을 사용하여 각 기능의 최적화를 도모하고 싶을 때, MSA는 각 마이크로서비스가 독립적으로 적합한 기술 스택을 선택할 수 있도록 합니다. 이는 기술적 유연성을 증대시키고 혁신을 촉진합니다.
### 빈번한 업데이트 및 빠른 배포 요구:
시장의 변화나 사용자의 요구에 신속하게 대응해야 할 필요성이 클 때, MSA는 독립적인 서비스 단위로 빠른 개발, 테스트, 배포를 가능하게 합니다. 이로 인해 전체 애플리케이션을 재배포하지 않고도 개별 서비스를 업데이트할 수 있습니다.
### 장애 격리와 시스템 안정성 강화:
시스템의 한 부분에 문제가 발생했을 때 전체 애플리케이션에 영향을 미치지 않도록 하고 싶을 때, MSA는 서비스 간 격리를 통해 장애가 다른 부분으로 전파되는 것을 방지하며, 시스템의 전반적인 가용성을 향상시킵니다.
### 비즈니스 요구의 다변화:
다양한 비즈니스 요구를 빠르게 수용하고, 비즈니스 로직을 서비스별로 분리하고 싶은 경우, MSA는 각각의 서비스를 비즈니스 기능에 맞추어 독립적으로 개발하고 관리할 수 있게 합니다.

# Q: MSA를 도입해서 얻는 장점

> Microservices Architecture (MSA)는 대규모 어플리케이션을 더 작고 독립적인 서비스로 나누는 구조 방식을 말합니다.
> 
> 이 구조는 각각의 서비스가 특정 기능을 담당하고 독립적으로 개발되며 배포될 수 있게 해줍니다.
 
## 예제: 온라인 쇼핑 플랫폼
### 1. 확장성
      상황:
      온라인 쇼핑 플랫폼이 성장하면서 트래픽이 급증하고, 특히 할인 이벤트 기간 동안에는 시스템 오버로드가 발생할 수 있습니다.

      MSA 적용:
      각 서비스(제품 검색, 주문 처리, 결제 시스템 등)를 독립적으로 확장할 수 있습니다.
      예를 들어, 할인 이벤트 기간 동안에는 주문 처리 서비스의 인스턴스를 더 많이 활성화하여 처리 능력을 증가시킬 수 있습니다.

### 2. 유연한 기술 스택
      상황:
      전체 시스템이 하나의 기술 스택에 의존하게 되면, 새로운 기술 도입이 어렵거나 기존 기술의 한계에 부딪힐 수 있습니다.
   
      MSA 적용:
      각 마이크로서비스는 독립적인 기술 스택을 가질 수 있습니다.
      예를 들어, 데이터 처리에는 Java를, 실시간 상호작용에는 Node.js를 사용할 수 있으며, 각각의 서비스가 최적의 기술을 선택하여 사용할 수 있습니다.
### 3. 빠른 배포와 혁신
      상황: 모놀리식 구조에서는 작은 변경사항이라도 전체 어플리케이션을 재배포해야 하는 경우가 많습니다.
   
      MSA 적용: 각 마이크로서비스는 독립적으로 배포될 수 있어 개발 주기가 짧아지고, 실패의 영향을 최소화할 수 있습니다.
      이는 신속한 기능 업데이트와 혁신을 가능하게 합니다.
### 4. 결함 격리 (Fault Isolation)
      상황:
      한 부분의 문제가 전체 시스템의 다운을 초래할 수 있습니다.
   
      MSA 적용:
      한 서비스에서 문제가 발생해도, 이는 해당 서비스로 제한되고 다른 서비스는 정상적으로 작동을 계속할 수 있습니다.
      이는 시스템의 전반적인 안정성을 향상시킵니다.
### 5. 개발 팀의 자율성 (Development Team Autonomy)
      상황:
      전체 어플리케이션을 한 팀 또는 몇 몇 팀이 관리할 때, 의사결정과 개발 프로세스에 있어 복잡성과 의존성이 증가합니다.
   
      MSA 적용:
      각 마이크로서비스를 담당하는 팀은 그 서비스에 대한 전체 책임을 지며, 자체적인 기술 선택, 설계, 개발 방식을 채택할 수 있습니다.
      이는 팀 내 의사결정을 간소화하고, 더 빠른 개발과 혁신을 가능하게 합니다.
   
 이러한 장점들은 MSA가 각 서비스의 독립성과 확장성을 높여줌으로써, 성장하는 서비스의 요구사항과 변화에 유연하게 대응할 수 있도록 해줍니다.
 
 특히, 성장 단계에 있는 서비스들은 시장과 기술 환경의 변화에 신속하게 대응하고, 고객의 요구에 맞춰 지속적으로 서비스를 개선하고 확장하는 것이 중요합니다.

# Q: 카프카와 레디스의 구조 차이
## Apache Kafka
Apache Kafka는 대규모 실시간 데이터 피드를 처리하도록 설계된 분산 이벤트 스트리밍 플랫폼입니다.\
Kafka는 높은 처리량과 내결함성을 지닌 메시징 시스템으로서, 데이터 파이프라인 및 실시간 분석을 위해 널리 사용됩니다.

### 구조적 특징:
### 1. 분산 시스템:
Kafka는 클러스터로 구성되며, 여러 브로커(서버)가 포함됩니다.\
이 구조는 데이터의 높은 가용성과 확장성을 보장합니다.
### 2. 토픽:
데이터는 토픽이라는 카테고리에 저장됩니다. 각 토픽은 여러 파티션으로 분할될 수 있으며, 각 파티션은 다수의 브로커에 걸쳐 복제될 수 있습니다.
### 3. 프로듀서와 컨슈머:
프로듀서는 데이터를 Kafka 클러스터로 보내고, 컨슈머는 저장된 데이터를 읽습니다. Kafka는 높은 처리량의 데이터를 효율적으로 처리할 수 있도록 프로듀서와 컨슈머 사이의 디쿠플링을 지원합니다.
### 4. 오프셋 관리:
Kafka는 각 메시지에 대해 유일한 오프셋을 할당하여, 컨슈머가 어느 메시지를 읽었는지 추적할 수 있게 합니다.

## Redis
Redis는 고성능 키-값 저장소로, 데이터를 메모리에 저장하여 빠른 읽기 및 쓰기를 제공합니다.\
주로 캐싱, 세션 관리, 게임 리더보드, 실시간 분석과 같은 고속 데이터 액세스가 요구되는 환경에서 사용됩니다.

### 구조적 특징:
### 1. 인메모리 데이터 스토어:
모든 데이터를 메모리에 저장하여 매우 빠른 데이터 액세스를 제공합니다.\
필요한 경우 디스크에도 데이터를 영속화할 수 있습니다.
### 2. 데이터 구조:
Redis는 단순한 키-값 쌍 뿐만 아니라, 리스트, 세트, 해시, 정렬된 세트 등 다양한 데이터 구조를 지원합니다.
### 3. 단일 스레드:
기본적으로 Redis는 단일 스레드 모델을 사용합니다. 이는 명령어 처리의 원자성을 보장하며, 복잡한 동시성 문제를 피할 수 있게 합니다.
### 4. Pub/Sub 시스템:
Redis는 간단한 메시징 기능도 제공합니다. 이는 퍼블리셔와 서브스크라이버간의 메시지 전달을 가능하게 합니다.

## 구조 차이
### 용도 및 최적화:
Kafka는 대량의 데이터 스트리밍 및 메시징에 최적화되어 있으며, 데이터를 지속적으로 디스크에 저장합니다. 반면, Redis는 빠른 데이터 접근을 위해 모든 데이터를 메모리에 저장합니다.
###  데이터 관리:
Kafka는 불변의 로그 시스템을 사용하여 데이터를 순차적으로 관리합니다. Redis는 보다 유연한 데이터 구조와 인메모리 처리를 통해 다양한 형태의 데이터 접근 및 수정을 지원합니다.
### 확장성 및 분산 처리:
Kafka는 자연스럽게 분산 처리 및 확장이 가능한 구조로 설계되어 있습니다. Redis 역시 클러스터 모드를 통해 분산 처리를 지원하지만, 주로 단일 노드의 성능을 극대화하는 데 초점을 맞춥니다.

# Q: 레디스의 펍섭 구조
Redis 펍섭은 라디오와 같은 형식이다.
브로드케스트되는 동안 구독하고 있는 사용자들만 값을 듣는다.
### Fire & Forgot:
레디스는 Fire & Forgot구조로 되어있는데, 발송뒤 각 데이터가 제대로 도착하는지는 관심을 가지지 않는다.\
그래서 만약 어떠한 문제로 메시지가 발행되었지만, 잠시 구독이 끊어지면 메시지를 받지 못한다.
### 팬아웃 전용:
메시지가 우선 모든 구독자에게 보내진다.\
그래서 모든 구독자는 메시지에 필터링 혹은 관심없는 데이터도 우선 받아야한다.

# Q: 레디스를 펍했는데 sub이 한명도 없는 경우

Redis에서는 Publisher가 메시지를 발행하고 해당 채널에 Subscriber가 한 명도 없는 경우, 그 메시지는 단순히 버려집니다.\
Redis의 Pub/Sub 시스템은 메시지를 저장하거나 큐잉하지 않으며, 메시지가 발행되는 순간에 구독하고 있는 클라이언트에게만 전송됩니다.

## 처리 방안

### 1. 메시지 큐 사용:
메시지의 내구성을 확보하기 위해 Apache Kafka와 같은 메시지 큐 시스템을 사용할 수 있습니다. 이런 시스템들은 메시지를 일정 시간 저장하고, 구독자가 나중에 연결되어도 메시지를 받을 수 있게 합니다.
### 2. 데이터베이스 또는 영구 저장소 사용:
중요 메시지를 데이터베이스에 저장하고, 구독자가 나중에 접속했을 때 해당 데이터를 검색하여 처리할 수 있습니다.
### 3. 예비 구독자 활용:
항상 메시지를 수신할 수 있는 예비 구독자(backup subscriber)를 두어서, 실제 구독자가 없는 경우 예비 구독자가 메시지를 받아 처리하거나 저장하는 방법도 있습니다.
### 4. 구독자 모니터링:
Redis의 PUBSUB 명령을 사용하여 현재 활성화된 구독자의 수를 모니터링하고, 구독자가 없을 때는 메시지를 발행하지 않도록 하는 로직을 구현할 수 있습니다.

# Q: 카프카 구조

## Kafka의 주요 구조
### 브로커:
Kafka 클러스터는 여러 브로커(broker)로 구성되며, 각 브로커는 메시지를 저장하고 처리하는 서버입니다.
### 토픽:
메시지는 토픽(topic)에 의해 분류됩니다. 각 토픽은 하나 이상의 파티션(partition)을 가질 수 있으며, 이는 데이터의 병렬 처리와 확장성을 증대시킵니다.
### 프로듀서:
데이터를 Kafka 시스템에 푸시하는 역할을 합니다. 프로듀서는 특정 토픽의 하나 이상의 파티션에 데이터를 발행(publish)합니다.
### 컨슈머:
데이터를 Kafka에서 소비하는 역할을 합니다. 컨슈머는 하나 이상의 토픽을 구독하고 데이터를 가져옵니다.
### 컨슈머 그룹:
여러 컨슈머가 동일한 토픽을 구독할 때, 컨슈머 그룹을 형성하여 파티션 간에 부하를 분산시킵니다.

## Kafka의 데이터 처리 방식

### 내구성과 신뢰성:
Kafka는 메시지를 디스크에 저장하고, 필요한 경우 이를 복제하여 데이터 손실을 방지합니다. 이는 Kafka의 메시지 처리가 "Fire and Forget"이 아닌, 내구성을 갖춘 구조임을 의미합니다.
### 팬아웃 메커니즘:
Kafka는 팬아웃을 지원하지만, 컨슈머 그룹을 통해 각 컨슈머가 동일한 메시지를 중복해서 받지 않고 토픽의 파티션에서 고유의 메시지 세트를 소비할 수 있습니다. 이는 효율적인 리소스 활용과 고정밀의 부하 분산을 가능하게 합니다.
### 오프셋 관리:
Kafka는 각 컨슈머의 오프셋(읽기 진행 상태)을 관리하여, 컨슈머가 처리한 마지막 메시지를 추적합니다. 이를 통해 컨슈머가 다시 연결되었을 때 중단한 지점부터 메시지를 소비할 수 있습니다.

# Q: 데이터 스트리밍의 장점과 설명

## 데이터 스트리밍의 주요 장점

### 1. 즉각적인 데이터 처리
> 데이터 스트리밍은 데이터가 생성되는 즉시 처리를 가능하게 하여, 거의 실시간의 데이터 분석과 반응을 제공합니다. 이는 비즈니스에서 중요한 시간적 이점을 제공하며, 특히 시장의 변화에 빠르게 대응해야 하는 금융 분야나, 실시간 사용자 행동 분석이 필요한 웹 서비스 등에서 큰 이점을 제공합니다.
### 2. 효율적인 리소스 활용
> 스트리밍은 데이터를 배치로 처리하는 대신 연속적으로 처리합니다. 이는 데이터 저장소에 데이터를 일시적으로 저장할 필요가 없으므로, 저장 공간의 효율적인 사용과 더 낮은 저장 비용을 가능하게 합니다.
### 3. 확장성
> 데이터 스트리밍 솔루션은 일반적으로 분산 아키텍처를 기반으로 하며, 이는 데이터 볼륨이 증가함에 따라 시스템을 수평적으로 쉽게 확장할 수 있음을 의미합니다. 예를 들어, Apache Kafka, Apache Flink와 같은 도구들은 높은 처리량을 지원하며, 클러스터에 노드를 추가하여 처리 능력을 증가시킬 수 있습니다.
### 4. 데이터의 유연한 처리
> 스트리밍 시스템은 다양한 소스에서 오는 데이터를 처리할 수 있으며, 필요에 따라 데이터를 변환, 결합, 필터링하는 등 다양한 방식으로 유연하게 데이터를 처리할 수 있습니다. 이는 데이터 파이프라인을 매우 유연하게 구성할 수 있도록 해, 다양한 데이터 소스와 애플리케이션 요구 사항에 적응할 수 있습니다.
### 5.실시간 의사결정 및 모니터링
> 스트리밍 데이터는 비즈니스 인텔리전스와 결합되어 조직이 실시간으로 의사결정을 내리는 데 도움을 줄 수 있습니다. 예를 들어, 생산 라인의 센서 데이터를 실시간으로 분석하여 장비 고장을 예방하거나, 온라인 트랜잭션을 실시간으로 모니터링하여 사기를 감지할 수 있습니다.

# Q: 데이터베이스 ACID

## 데이터베이스 트랜잭션과 격리성
### 원자성(Atomicity)
> 트랜잭션은 더 이상 분해가 불가능한 업무의 최소단위이므로, 전부 처리되거나 아예 하나도 처리되지 않아야 한다.
### 일관성(Consistency)
> 일관된 상태의 데이터베이스에서 하나의 트랜잭션을 성공적으로 완료하고 나면 그 데이터베이스는 여전히 일관된 상태여야 한다.
> 
> 즉, 트랜잭션 실행의 결과로 데이터베이스 상태가 모순되지 않아야 한다.
### 격리성(Isolation)
> 실행 중인 트랜잭션의 중간결과를 다른 트랜잭션이 접근할 수 없다.
### 영속성(Durability)
> 트랜잭션이 일단 그 실행을 성공적으로 완료하면 그 결과는 데이터베이스에 영속적으로 저장된다.

# Q: 트랜잭션의 고립성 설명

## 고립 수준 (Isolation Levels)
> SQL 표준은 다양한 고립 수준을 정의하여, 데이터베이스 시스템이 동시성과 고립성 간의 균형을 어떻게 맞출지 결정할 수 있도록 합니다. 이러한 고립 수준에는 다음이 포함됩니다:

### Read Uncommitted:
   가장 낮은 고립 수준으로, 다른 트랜잭션에 의해 커밋되지 않은 변경 내용을 다른 트랜잭션이 읽을 수 있습니다.
### Read Committed:
   이 수준에서는 트랜잭션이 커밋된 데이터만 읽을 수 있으며, "dirty reads"는 방지하지만 "non-repeatable reads"는 발생할 수 있습니다.
### Repeatable Read:
   한 트랜잭션 내에서 읽은 데이터는 그 트랜잭션이 종료될 때까지 다른 트랜잭션에 의해 변경될 수 없습니다. 이는 "non-repeatable reads"를 방지하지만 "phantom reads"는 여전히 가능합니다.
### Serializable:
   가장 높은 고립 수준으로, 트랜잭션이 마치 순차적으로 실행되는 것처럼 처리됩니다. 이 수준에서는 "dirty reads", "non-repeatable reads", 그리고 "phantom reads" 모두 방지됩니다.

      각 고립 수준은 성능과 일관성 사이의 트레이드오프를 제공합니다.
      더 높은 고립 수준은 더 나은 데이터 일관성을 보장하지만,
      동시성 수준이 낮아지고 성능이 저하될 수 있습니다.
